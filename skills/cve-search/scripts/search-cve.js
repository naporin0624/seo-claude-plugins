#!/usr/bin/env node

/**
 * CVE Search - NVD API 2.0 Client
 *
 * Searches the National Vulnerability Database for CVEs.
 * Rate limit: 5 requests/30s (public), 50 requests/30s (with API key)
 */

const NVD_API_BASE = "https://services.nvd.nist.gov/rest/json/cves/2.0";

// Parse command line arguments
function parseArgs(args) {
  const options = {
    keyword: null,
    cveId: null,
    cweId: null,
    severity: null,
    days: null,
    limit: 10,
    apiKey: process.env.NVD_API_KEY || null
  };

  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case '--keyword':
      case '-k':
        options.keyword = args[++i];
        break;
      case '--cve':
        options.cveId = args[++i];
        break;
      case '--cwe':
        options.cweId = args[++i];
        break;
      case '--severity':
      case '-s':
        options.severity = args[++i]?.toUpperCase();
        break;
      case '--days':
      case '-d':
        options.days = parseInt(args[++i], 10);
        break;
      case '--limit':
      case '-l':
        options.limit = parseInt(args[++i], 10);
        break;
      case '--api-key':
        options.apiKey = args[++i];
        break;
      case '--help':
      case '-h':
        printHelp();
        process.exit(0);
    }
  }

  return options;
}

function printHelp() {
  console.log(`
CVE Search - NVD API 2.0 Client

Usage:
  node search-cve.js [options]

Options:
  --keyword, -k <term>    Search by keyword (software name, vendor)
  --cve <id>              Search by specific CVE ID (e.g., CVE-2021-44228)
  --cwe <id>              Filter by CWE ID (e.g., CWE-79)
  --severity, -s <level>  Filter by severity (CRITICAL, HIGH, MEDIUM, LOW)
  --days, -d <n>          Published in last N days
  --limit, -l <n>         Max results (default: 10)
  --api-key <key>         NVD API key (or set NVD_API_KEY env var)
  --help, -h              Show this help

Examples:
  node search-cve.js --keyword "jquery"
  node search-cve.js --cve "CVE-2021-44228"
  node search-cve.js --cwe "CWE-89" --severity "CRITICAL"
  node search-cve.js --keyword "apache" --days 30
`);
}

async function searchCVE(options) {
  const params = new URLSearchParams();

  if (options.keyword) {
    params.set("keywordSearch", options.keyword);
  }

  if (options.cveId) {
    params.set("cveId", options.cveId);
  }

  if (options.cweId) {
    // Remove "CWE-" prefix if present for API
    const cweId = options.cweId.replace(/^CWE-/i, "");
    params.set("cweId", `CWE-${cweId}`);
  }

  if (options.severity) {
    params.set("cvssV3Severity", options.severity);
  }

  if (options.days) {
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - options.days);

    params.set("pubStartDate", startDate.toISOString());
    params.set("pubEndDate", endDate.toISOString());
  }

  params.set("resultsPerPage", String(options.limit));

  const url = `${NVD_API_BASE}?${params.toString()}`;

  const headers = {
    "Accept": "application/json"
  };

  if (options.apiKey) {
    headers["apiKey"] = options.apiKey;
  }

  try {
    const response = await fetch(url, { headers });

    if (!response.ok) {
      if (response.status === 403) {
        throw new Error("Rate limit exceeded. Wait 30 seconds and try again.");
      }
      throw new Error(`API error: ${response.status} ${response.statusText}`);
    }

    return await response.json();
  } catch (error) {
    if (error.message.includes("fetch")) {
      throw new Error("Network error. Check your internet connection.");
    }
    throw error;
  }
}

function formatCVE(vuln) {
  const cve = vuln.cve;

  // Get English description
  const description = cve.descriptions?.find(d => d.lang === "en")?.value || "No description available";

  // Get CVSS v3.1 metrics (prefer v3.1, fallback to v3.0)
  const cvssV31 = cve.metrics?.cvssMetricV31?.[0];
  const cvssV30 = cve.metrics?.cvssMetricV30?.[0];
  const cvss = cvssV31 || cvssV30;

  const severity = cvss?.cvssData?.baseSeverity || "UNKNOWN";
  const score = cvss?.cvssData?.baseScore || "N/A";
  const attackVector = cvss?.cvssData?.attackVector || "UNKNOWN";
  const attackComplexity = cvss?.cvssData?.attackComplexity || "UNKNOWN";
  const privilegesRequired = cvss?.cvssData?.privilegesRequired || "UNKNOWN";
  const userInteraction = cvss?.cvssData?.userInteraction || "UNKNOWN";

  // Get CWEs
  const cwes = cve.weaknesses?.flatMap(w =>
    w.description?.filter(d => d.lang === "en").map(d => d.value)
  ).filter(Boolean) || [];

  // Get references (first 5)
  const references = cve.references?.slice(0, 5).map(r => r.url) || [];

  // Check for exploit tags
  const hasExploit = cve.references?.some(r =>
    r.tags?.some(t => t.toLowerCase().includes("exploit"))
  );

  // Estimate bounty based on severity
  const bountyEstimate = {
    "CRITICAL": "$5,000 - $50,000+",
    "HIGH": "$2,000 - $10,000",
    "MEDIUM": "$500 - $3,000",
    "LOW": "$100 - $500"
  }[severity] || "Varies";

  return {
    id: cve.id,
    description: description.substring(0, 500) + (description.length > 500 ? "..." : ""),
    severity,
    score,
    bountyEstimate,
    attackVector,
    attackComplexity,
    privilegesRequired,
    userInteraction,
    cwes,
    references,
    hasExploit,
    published: cve.published,
    lastModified: cve.lastModified
  };
}

function printResult(cve) {
  const severityEmoji = {
    "CRITICAL": "ðŸ”´",
    "HIGH": "ðŸŸ ",
    "MEDIUM": "ðŸŸ¡",
    "LOW": "ðŸŸ¢"
  }[cve.severity] || "âšª";

  const bountyEmoji = cve.severity === "CRITICAL" ? "ðŸ’°ðŸ’°ðŸ’°" :
                      cve.severity === "HIGH" ? "ðŸ’°ðŸ’°" :
                      cve.severity === "MEDIUM" ? "ðŸ’°" : "";

  console.log(`
### ${cve.id} ${severityEmoji} ${bountyEmoji}

**Severity**: ${cve.severity} (${cve.score})
**Bounty Estimate**: ${cve.bountyEstimate}

**Description**:
${cve.description}

**Attack Vector**:
- Vector: ${cve.attackVector}
- Complexity: ${cve.attackComplexity}
- Privileges Required: ${cve.privilegesRequired}
- User Interaction: ${cve.userInteraction}

**CWE**: ${cve.cwes.length > 0 ? cve.cwes.join(", ") : "Not specified"}

**Exploit Available**: ${cve.hasExploit ? "Yes âš ï¸" : "Unknown"}

**References**:
${cve.references.map(r => `- ${r}`).join("\n")}

**Published**: ${new Date(cve.published).toLocaleDateString()}
---`);
}

function printJSON(cves) {
  console.log(JSON.stringify(cves, null, 2));
}

async function main() {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    printHelp();
    process.exit(0);
  }

  const options = parseArgs(args);

  if (!options.keyword && !options.cveId && !options.cweId) {
    console.error("Error: At least one of --keyword, --cve, or --cwe is required");
    process.exit(1);
  }

  console.error(`Searching NVD...`);

  try {
    const result = await searchCVE(options);

    if (!result.vulnerabilities || result.vulnerabilities.length === 0) {
      console.log("No CVEs found matching your criteria.");
      process.exit(0);
    }

    console.log(`\n# CVE Search Results\n`);
    console.log(`Found ${result.totalResults} total results (showing ${result.vulnerabilities.length})\n`);

    const cves = result.vulnerabilities.map(formatCVE);

    // Sort by severity (CRITICAL first)
    const severityOrder = { "CRITICAL": 0, "HIGH": 1, "MEDIUM": 2, "LOW": 3, "UNKNOWN": 4 };
    cves.sort((a, b) => (severityOrder[a.severity] || 4) - (severityOrder[b.severity] || 4));

    // Check if --json flag is present
    if (args.includes("--json")) {
      printJSON(cves);
    } else {
      cves.forEach(printResult);

      // Summary
      const critical = cves.filter(c => c.severity === "CRITICAL").length;
      const high = cves.filter(c => c.severity === "HIGH").length;
      const withExploit = cves.filter(c => c.hasExploit).length;

      console.log(`\n## Summary`);
      console.log(`- Critical: ${critical}`);
      console.log(`- High: ${high}`);
      console.log(`- With known exploits: ${withExploit}`);

      if (critical > 0 || (high > 0 && withExploit > 0)) {
        console.log(`\nðŸ’° **High bounty potential detected!**`);
      }
    }

  } catch (error) {
    console.error(`Error: ${error.message}`);
    process.exit(1);
  }
}

main();
